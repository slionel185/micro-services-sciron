{"version":3,"sources":["../index.ts"],"sourcesContent":["import { z, type ZodError, type ZodObject, type ZodType } from \"zod\";\n\nexport type ErrorMessage<T extends string> = T;\nexport type Simplify<T> = {\n  [P in keyof T]: T[P];\n  // eslint-disable-next-line @typescript-eslint/ban-types\n} & {};\n\nexport interface BaseOptions {\n  /**\n   * How to determine whether the app is running on the server or the client.\n   * @default typeof window === \"undefined\"\n   */\n  isServer?: boolean;\n\n  /**\n   * Called when validation fails. By default the error is logged,\n   * and an error is thrown telling what environment variables are invalid.\n   */\n  onValidationError?: (error: ZodError) => never;\n\n  /**\n   * Called when a server-side environment variable is accessed on the client.\n   * By default an error is thrown.\n   */\n  onInvalidAccess?: (variable: string) => never;\n\n  /**\n   * Whether to skip validation of environment variables.\n   * @default false\n   */\n  skipValidation?: boolean;\n}\n\nexport interface ClientOptions<\n  TPrefix extends string,\n  TClient extends Record<string, ZodType>\n> {\n  /**\n   * Client-side environment variables are exposed to the client by default. Set what prefix they have\n   */\n  clientPrefix: TPrefix;\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app isn't\n   * built with invalid env vars. To expose them to the client, prefix them with `NEXT_PUBLIC_`.\n   */\n  client: {\n    [TKey in keyof TClient]: TKey extends `${TPrefix}${string}`\n      ? TClient[TKey]\n      : ErrorMessage<`${TKey extends string\n          ? TKey\n          : never} is not prefixed with ${TPrefix}.`>;\n  };\n}\n\nexport interface WithoutClientOptions {\n  clientPrefix?: never;\n  client?: never;\n}\n\nexport interface ServerOptions<\n  TPrefix extends string,\n  TServer extends Record<string, ZodType>\n> {\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app isn't\n   * built with invalid env vars.\n   */\n  server: {\n    [TKey in keyof TServer]: TPrefix extends \"\"\n      ? TServer[TKey]\n      : TKey extends `${TPrefix}${string}`\n      ? ErrorMessage<`${TKey extends `${TPrefix}${string}`\n          ? TKey\n          : never} should not prefixed with ${TPrefix}.`>\n      : TServer[TKey];\n  };\n}\n\nexport interface WithoutServerOptions {\n  server?: never;\n}\n\nexport interface LooseOptions extends BaseOptions {\n  runtimeEnvStrict?: never;\n  /**\n   * Runtime Environment variables to use for validation - `process.env`, `import.meta.env` or similar.\n   * Unlike `runtimeEnvStrict`, this doesn't enforce that all environment variables are set.\n   */\n  runtimeEnv: Record<string, string | boolean | number | undefined>;\n}\n\nexport interface StrictOptions<\n  TPrefix extends string,\n  TServer extends Record<string, ZodType>,\n  TClient extends Record<string, ZodType>\n> extends BaseOptions {\n  /**\n   * Runtime Environment variables to use for validation - `process.env`, `import.meta.env` or similar.\n   * Enforces all environment variables to be set. Required in for example Next.js Edge and Client runtimes.\n   */\n  runtimeEnvStrict: Record<\n    | {\n        [TKey in keyof TClient]: TKey extends `${TPrefix}${string}`\n          ? TKey\n          : never;\n      }[keyof TClient]\n    | {\n        [TKey in keyof TServer]: TKey extends `${TPrefix}${string}`\n          ? never\n          : TKey;\n      }[keyof TServer],\n    string | boolean | number | undefined\n  >;\n  runtimeEnv?: never;\n}\n\nexport type ServerClientOptions<\n  TPrefix extends string,\n  TServer extends Record<string, ZodType>,\n  TClient extends Record<string, ZodType>\n> =\n  | (ClientOptions<TPrefix, TClient> & ServerOptions<TPrefix, TServer>)\n  | (WithoutClientOptions & ServerOptions<TPrefix, TServer>)\n  | (ClientOptions<TPrefix, TClient> & WithoutServerOptions);\n\nexport type createEnvParams<\n  TPrefix extends string,\n  TServer extends Record<string, ZodType>,\n  TClient extends Record<string, ZodType>\n> =\n  | (LooseOptions & ServerClientOptions<TPrefix, TServer, TClient>)\n  | (StrictOptions<TPrefix, TServer, TClient> &\n      ServerClientOptions<TPrefix, TServer, TClient>);\n\nexport function createEnv<\n  TPrefix extends string = \"\",\n  TServer extends Record<string, ZodType> = NonNullable<unknown>,\n  TClient extends Record<string, ZodType> = NonNullable<unknown>\n>(\n  opts: createEnvParams<TPrefix, TServer, TClient>\n): Simplify<z.infer<ZodObject<TServer>> & z.infer<ZodObject<TClient>>> {\n  const runtimeEnv = opts.runtimeEnvStrict ?? opts.runtimeEnv ?? process.env;\n\n  const skip = !!opts.skipValidation;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-explicit-any\n  if (skip) return runtimeEnv as any;\n\n  const _client = typeof opts.client === \"object\" ? opts.client : {};\n  const _server = typeof opts.server === \"object\" ? opts.server : {};\n  const client = z.object(_client);\n  const server = z.object(_server);\n  const isServer = opts.isServer ?? typeof window === \"undefined\";\n\n  const merged = server.merge(client);\n  const parsed = isServer\n    ? merged.safeParse(runtimeEnv) // on server we can validate all env vars\n    : client.safeParse(runtimeEnv); // on client we can only validate the ones that are exposed\n\n  const onValidationError =\n    opts.onValidationError ??\n    ((error: ZodError) => {\n      console.error(\n        \"❌ Invalid environment variables:\",\n        error.flatten().fieldErrors\n      );\n      throw new Error(\"Invalid environment variables\");\n    });\n\n  const onInvalidAccess =\n    opts.onInvalidAccess ??\n    ((_variable: string) => {\n      throw new Error(\n        \"❌ Attempted to access a server-side environment variable on the client\"\n      );\n    });\n\n  if (parsed.success === false) {\n    return onValidationError(parsed.error);\n  }\n\n  const env = new Proxy(parsed.data, {\n    get(target, prop) {\n      if (typeof prop !== \"string\") return undefined;\n      if (\n        !isServer &&\n        opts.clientPrefix &&\n        !prop.startsWith(opts.clientPrefix)\n      ) {\n        return onInvalidAccess(prop);\n      }\n      return target[prop as keyof typeof target];\n    },\n  });\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-explicit-any\n  return env as any;\n}\n"],"mappings":"AAAA,OAAS,KAAAA,MAAsD,MAwIxD,SAASC,EAKdC,EACqE,CACrE,IAAMC,EAAaD,EAAK,kBAAoBA,EAAK,YAAc,QAAQ,IAIvE,GAFa,CAAC,CAACA,EAAK,eAEV,OAAOC,EAEjB,IAAMC,EAAU,OAAOF,EAAK,QAAW,SAAWA,EAAK,OAAS,CAAC,EAC3DG,EAAU,OAAOH,EAAK,QAAW,SAAWA,EAAK,OAAS,CAAC,EAC3DI,EAASN,EAAE,OAAOI,CAAO,EACzBG,EAASP,EAAE,OAAOK,CAAO,EACzBG,EAAWN,EAAK,UAAY,OAAO,OAAW,IAE9CO,EAASF,EAAO,MAAMD,CAAM,EAC5BI,EAASF,EACXC,EAAO,UAAUN,CAAU,EAC3BG,EAAO,UAAUH,CAAU,EAEzBQ,EACJT,EAAK,oBACHU,GAAoB,CACpB,cAAQ,MACN,wCACAA,EAAM,QAAQ,EAAE,WAClB,EACM,IAAI,MAAM,+BAA+B,CACjD,GAEIC,EACJX,EAAK,kBACHY,GAAsB,CACtB,MAAM,IAAI,MACR,6EACF,CACF,GAEF,OAAIJ,EAAO,UAAY,GACdC,EAAkBD,EAAO,KAAK,EAG3B,IAAI,MAAMA,EAAO,KAAM,CACjC,IAAIK,EAAQC,EAAM,CAChB,GAAI,OAAOA,GAAS,SACpB,MACE,CAACR,GACDN,EAAK,cACL,CAACc,EAAK,WAAWd,EAAK,YAAY,EAE3BW,EAAgBG,CAAI,EAEtBD,EAAOC,CAA2B,CAC3C,CACF,CAAC,CAIH","names":["z","createEnv","opts","runtimeEnv","_client","_server","client","server","isServer","merged","parsed","onValidationError","error","onInvalidAccess","_variable","target","prop"]}